/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package VideoColourAnalyser;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import javax.imageio.ImageIO;
import javax.swing.JFrame;

import org.bytedeco.javacv.FFmpegFrameGrabber;
import org.bytedeco.javacv.Frame;
import org.bytedeco.javacv.Java2DFrameConverter;


import java.awt.Color;


import java.awt.image.BufferedImage;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    private static List<ColorWeight> parseImage(BufferedImage image) throws IOException {
        HashMap<Color,Integer> colors = new HashMap<>();
        System.out.println("MMMMMMMNNNNNNOOOOO" + image.getWidth() + " aaaaaaaa");
        for (int x = 0; x <image.getWidth(); x++) {
            for (int y = 0; y< image.getHeight(); y++) {
                int clr = image.getRGB(x, y);
                Color color = new Color(clr);
                if (colors.containsKey(color)) {
                    colors.put(color, colors.get(color) + 1);
                }
                else {
                    colors.put(color, 1);    
                }
            }
        }
        List<ColorWeight> colorsByWeight = new ArrayList<>();
        for (Map.Entry<Color, Integer> entry : colors.entrySet()) {
            colorsByWeight.add(new ColorWeight(entry.getKey(), entry.getValue()));
        }
        colorsByWeight.sort(new ByHSB());
        return colorsByWeight;
    }

    private static HashMap<Centroid, List<ColorWeight>> delegateMeans(List<ColorWeight> colorsByWeight, int k) {
        // System.out.println("sorting");
        // colorsByWeight.sort(new ByHSB());
        HashMap<Centroid, List<ColorWeight>> meansToClusters = new HashMap<>();
        System.out.println("Initialising");
        // for (i = 0; i<colorsByWeight.size(); i += (colorsByWeight.size()/numOfDom)) {
        // for (int i = 0; i<k; i += 1) {
        //     meansToClusters.put(new Centroid( Arrays.asList(colorsByWeight.get(i * colorsByWeight.size()/ k))), new ArrayList<>());
        // }
        for (int i = 0; i<k; i += 1) {
            List<ColorWeight> currCol = new ArrayList<>();
            for (int p = i*colorsByWeight.size()/k; p<(i+1)*colorsByWeight.size()/k; p += 1) {
                currCol.add(colorsByWeight.get(p));
            }
            meansToClusters.put(new Centroid(currCol), currCol);
        }
        return meansToClusters;
    }

    private static List<Centroid> kMeansCluster(List<ColorWeight> colorsByWeight, int k) {
        HashMap<Centroid, List<ColorWeight>> meansToClusters = new HashMap<>();
        // HashMap<Centroid, List<ColorWeight>> rearrangedClusters = new HashMap<>();
        meansToClusters = delegateMeans(colorsByWeight, k);
        // meansToClusters = randMeansToClusters(colorsByWeight, k);
        // meansToClusters = forgyMeansToClusters(colorsByWeight, k);
        
        // Here, we need initial means to be set
        while (true)
        {
            // Assign clusters
            for (ColorWeight curr: colorsByWeight) {
                float dist = 0;
                Centroid closest = null;
                for(Centroid key : meansToClusters.keySet()) {
                    if(closest == null || key.distFromColor(curr) < dist) {
                        dist = key.distFromColor(curr);
                        closest = key;
                    }
                }
                meansToClusters.get(closest).add(curr);
            }
 
            boolean noChange = true;
            for (Centroid c : meansToClusters.keySet()) {
                if (c.recalculateCentroid(meansToClusters.get(c))) {
                    noChange = false;
                }
            }
            if (noChange) {
                break;
            }
        }
        return new ArrayList<>(meansToClusters.keySet());
    }

    private static void graphColour(List<ColorWeight> colors,int k) {
        
        List<Centroid> centroids = kMeansCluster(colors,k);
        List<ColorWeight> means = centroids.stream().map(o-> o.getColorWeight()).collect(Collectors.toList());
        displayColors(means);

    }

    private static void displayColors(List<ColorWeight> means) {
        DominantRectangle rect = new DominantRectangle(means);
        JFrame window = new JFrame();
        window.setSize(800, 800);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.add(rect);

        window.setVisible(true);
    }

    private static void findDominantColors(List<ColorWeight> colorsByWeight) {
        
        List<Centroid> centroids = kMeansCluster(colorsByWeight,5);

        List<ColorWeight> means = centroids.stream().map(o-> o.getColorWeight()).collect(Collectors.toList());
        List<ColorWeight> lastMeans = means;
        double dist = centroids.stream().mapToDouble(Centroid::sumDistanceFromMean).sum(); 
        double lastDistance = 2*dist;
        // for (int k=2; k<12; k++) {
        int k = 6;
        while(lastDistance * 0.85 > dist) {
        // while(lastDistance/ dist > 1.15) {
            lastDistance = dist;
            centroids = kMeansCluster(colorsByWeight,k);
            lastMeans = means;
            means = centroids.stream().map(o-> o.getColorWeight()).collect(Collectors.toList());
            dist = centroids.stream().mapToDouble(Centroid::sumDistanceFromMean).sum();
            k++;
        }
        displayColors(lastMeans);
    }

    public static void main(String []args) throws IOException, Exception
    {
        File myObj = new File("C:\\Users\\damia\\OneDrive\\Documents\\Code\\VideoAnalyser\\videos\\aoftlriri.mp4");
        FFmpegFrameGrabber frameGrabber = new FFmpegFrameGrabber(myObj.getAbsoluteFile());
        frameGrabber.setFormat("mp4");
        List<ColorWeight> colors = new ArrayList<>();
        // frameGrabber.setFrameRate(2.0);

        frameGrabber.start(); 
        System.out.println("gggppp" + frameGrabber.getFrameRate());
        // System.out.println("gggppp" + frameGrabber.getFrameRate());
        Frame f; 

        // boolean dog = true;
        Java2DFrameConverter c = new Java2DFrameConverter(); 
        int o = 0;
        List<Color> aveColorsInOrder = new ArrayList<>();
        while ((f = frameGrabber.grab()) != null) {
            o++;
            if (o%2 == 0) {
                try {

                    BufferedImage bi = c.convert(f);;
                    aveColorsInOrder.add(ColorWeight.averageWeights(parseImage(bi)));
                    if (o%10 == 0) {
                        System.out.println(o);
                            // ImageIO.write(bi, "png", new File("C:\\Users\\damia\\OneDrive\\Documents\\Code\\VideoAnalyser\\videos\\photos\\riri" + o + ".png"));
                            colors.addAll(parseImage(bi));
                            // ImageIO.write(bi,"png", new File("C:\\Users\\damia\\OneDrive\\Documents\\Code\\Images\\banana" + p + ".jpg"));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }

            }
        }
        
        VideoDissect rect = new VideoDissect(aveColorsInOrder);
        JFrame window = new JFrame();
        window.setSize(800, 800);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.add(rect);

        window.setVisible(true);

        List<ColorWeight> cws = ColorWeight.condenseWeights(colors);
        cws.sort(new ByHSB());
        // findDominantColors(cws);
        graphColour(cws, 8);
        frameGrabber.stop();
        
    }
}
