/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package VideoColourAnalyser;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.nio.Buffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import javax.imageio.ImageIO;
import javax.swing.Action;
import javax.swing.JFrame;

import org.bytedeco.ffmpeg.avutil.LogCallback;
import org.bytedeco.javacv.FFmpegFrameGrabber;
import org.bytedeco.javacv.Frame;
import org.bytedeco.javacv.Java2DFrameConverter;

import org.bytedeco.javacv.FFmpegLogCallback;



import java.awt.Color;


import java.awt.image.BufferedImage;

public class App {
    
    File file;
    HashMap<Color, Integer> colors = new HashMap<>();
    public App(File file) {
        this.file = file;
    }

    private static List<ColorWeight> parseImage(BufferedImage image) throws IOException {
        HashMap<Color,Integer> colors = new HashMap<>();
        for (int x = 0; x <image.getWidth(); x++) {
            for (int y = 0; y< image.getHeight(); y++) {
                int clr = image.getRGB(x, y);
                Color color = new Color(clr);
                if (colors.containsKey(color)) {
                    colors.put(color, colors.get(color) + 1);
                }
                else {
                    colors.put(color, 1);    
                }
            }
        }
        List<ColorWeight> colorsByWeight = new ArrayList<>();
        for (Map.Entry<Color, Integer> entry : colors.entrySet()) {
            colorsByWeight.add(new ColorWeight(entry.getKey(), entry.getValue()));
        }
        colorsByWeight.sort(new ByHSB());
        return colorsByWeight;
    }

    private void addImageToColors(BufferedImage image) {
        for (int x = 0; x <image.getWidth(); x++) {
            for (int y = 0; y< image.getHeight(); y++) {
                int clr = image.getRGB(x, y);
                Color color = new Color(clr);
                if (colors.containsKey(color)) {
                    colors.put(color, colors.get(color) + 1);
                }
                else {
                    colors.put(color, 1);    
                }
            }
        }
    }

    private static HashMap<Centroid, List<ColorWeight>> delegateMeans(List<ColorWeight> colorsByWeight, int k) {
        // System.out.println("sorting");
        // colorsByWeight.sort(new ByHSB());
        HashMap<Centroid, List<ColorWeight>> meansToClusters = new HashMap<>();
        System.out.println("Initialising");
        // for (i = 0; i<colorsByWeight.size(); i += (colorsByWeight.size()/numOfDom)) {
        // for (int i = 0; i<k; i += 1) {
        //     meansToClusters.put(new Centroid( Arrays.asList(colorsByWeight.get(i * colorsByWeight.size()/ k))), new ArrayList<>());
        // }
        for (int i = 0; i<k; i += 1) {
            List<ColorWeight> currCol = new ArrayList<>();
            for (int p = i*colorsByWeight.size()/k; p<(i+1)*colorsByWeight.size()/k; p += 1) {
                currCol.add(colorsByWeight.get(p));
            }
            meansToClusters.put(new Centroid(currCol), currCol);
        }
        return meansToClusters;
    }

    private static List<Centroid> kMeansCluster(List<ColorWeight> colorsByWeight, int k) {
        HashMap<Centroid, List<ColorWeight>> meansToClusters = new HashMap<>();
        // HashMap<Centroid, List<ColorWeight>> rearrangedClusters = new HashMap<>();
        meansToClusters = delegateMeans(colorsByWeight, k);
        // meansToClusters = randMeansToClusters(colorsByWeight, k);
        // meansToClusters = forgyMeansToClusters(colorsByWeight, k);
        
        // Here, we need initial means to be set
        while (true)
        {
            // Assign clusters
            for (ColorWeight curr: colorsByWeight) {
                float dist = 0;
                Centroid closest = null;
                for(Centroid key : meansToClusters.keySet()) {
                    if(closest == null || key.distFromColor(curr) < dist) {
                        dist = key.distFromColor(curr);
                        closest = key;
                    }
                }
                meansToClusters.get(closest).add(curr);
            }
 
            boolean noChange = true;
            for (Centroid c : meansToClusters.keySet()) {
                if (c.recalculateCentroid(meansToClusters.get(c))) {
                    noChange = false;
                }
            }
            if (noChange) {
                break;
            }
        }
        return new ArrayList<>(meansToClusters.keySet());
    }

    private static void graphColour(List<ColorWeight> colors,int k) {
        
        List<Centroid> centroids = kMeansCluster(colors,k);
        List<ColorWeight> means = centroids.stream().map(o-> o.getColorWeight()).collect(Collectors.toList());
        displayColors(means);

    }

    private static void displayColors(List<ColorWeight> means) {
        DominantRectangle rect = new DominantRectangle(means);
        JFrame window = new JFrame();
        window.setSize(800, 800);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.add(rect);

        window.setVisible(true);
    }

    private static void findDominantColors(List<ColorWeight> colorsByWeight) {
        
        List<Centroid> centroids = kMeansCluster(colorsByWeight,5);

        List<ColorWeight> means = centroids.stream().map(o-> o.getColorWeight()).collect(Collectors.toList());
        List<ColorWeight> lastMeans = means;
        double dist = centroids.stream().mapToDouble(Centroid::sumDistanceFromMean).sum(); 
        double lastDistance = 2*dist;
        // for (int k=2; k<12; k++) {
        int k = 6;
        while(lastDistance * 0.85 > dist) {
        // while(lastDistance/ dist > 1.15) {
            lastDistance = dist;
            centroids = kMeansCluster(colorsByWeight,k);
            lastMeans = means;
            means = centroids.stream().map(o-> o.getColorWeight()).collect(Collectors.toList());
            dist = centroids.stream().mapToDouble(Centroid::sumDistanceFromMean).sum();
            k++;
        }
        displayColors(lastMeans);
    }

    private List<ColorWeight> getColorWeights() {
        List<ColorWeight> cws = new ArrayList<>();
        for (Color cw : colors.keySet()) {
            cws.add(new ColorWeight(cw, colors.get(cw)));
        }
        return cws;
    }

    private void processVideo(int targFPS) throws Exception {
        StopWatch();
        FFmpegFrameGrabber frameGrabber = new FFmpegFrameGrabber(file.getAbsoluteFile());
        frameGrabber.setFormat("mp4");
        // frameGrabber.setFrameRate(2.0);
        // FFmpegLogCallback.set();
        frameGrabber.start(); 
        StopWatch("frame grabber initialised");
        Frame f; 

        Java2DFrameConverter c = new Java2DFrameConverter(); 
        int totalFrames = 0;
        double includedFrames = 0;
        
        double FPSConversionRate = targFPS/frameGrabber.getFrameRate();  
        System.out.println("fps: " + FPSConversionRate);

        List<Color> aveColorsInOrder = new ArrayList<>();
        StopWatch();

        while ((f = frameGrabber.grab()) != null) {
            try {
                BufferedImage bi = c.convert(f);;
                if (bi == null) {
                    // Audio frame, discarded
                    // System.out.println("audio frame");
                    continue;
                }
                // System.out.println("video frame");
                totalFrames++;
                aveColorsInOrder.add(ColorWeight.averageWeights(parseImage(bi)));
                if (includedFrames/totalFrames < FPSConversionRate) {
                    addImageToColors(bi);
                    includedFrames++;
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        c.close();
        StopWatch(aveColorsInOrder.size() + " frames processed");
        StopWatch();
        VideoDissect rect = new VideoDissect(aveColorsInOrder);
        StopWatch("Video dissect generated");
        JFrame window = new JFrame();
        window.setSize(800, 800);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.add(rect);

        window.setVisible(true);
        StopWatch();
        List<ColorWeight> cws = getColorWeights();
        cws.sort(new ByHSB());
        StopWatch("Colours sorted");
        // findDominantColors(cws);
        StopWatch();
        graphColour(cws, 8);
        StopWatch("8 colours generated");
        frameGrabber.stop();
    }

    
    private void processVideoDissect() throws Exception {
        StopWatch();
        FFmpegFrameGrabber frameGrabber = new FFmpegFrameGrabber(file.getAbsoluteFile());
        frameGrabber.setFormat("mp4");
        // frameGrabber.setFrameRate(2.0);
        // FFmpegLogCallback.set();
        frameGrabber.start(); 
        StopWatch("frame grabber initialised");
        Frame f; 

        Java2DFrameConverter c = new Java2DFrameConverter(); 
        
        List<Color> aveColorsInOrder = new ArrayList<>();

        while ((f = frameGrabber.grab()) != null) {
            try {
                BufferedImage bi = c.convert(f);;
                if (bi == null) {
                    // Audio frame, discarded
                    // System.out.println("audio frame");
                    continue;
                }
                // System.out.println("video frame");
                
                aveColorsInOrder.add(ColorWeight.averageWeights(parseImage(bi)));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        c.close();
        VideoDissect rect = new VideoDissect(aveColorsInOrder);
        JFrame window = new JFrame();
        window.setSize(800, 800);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.add(rect);

        window.setVisible(true);
        // // List<ColorWeight> cws = getColorWeights();
        // // cws.sort(new ByHSB());
        // // // findDominantColors(cws);
        // // StopWatch();
        // // graphColour(cws, 8);
        // StopWatch("8 colours generated");
        frameGrabber.stop();
    }

    private boolean active = false;
    private long startime;
    private void StopWatch(String text) {
        if (active) {
            active=false;
            System.out.println(text + " in " + (System.nanoTime()-startime)/1000000000 + " seconds");
        }
        else {
            active = true;
            startime = System.nanoTime();
        }
    }

    private void StopWatch() {
        StopWatch("Lap done");
    }
    
    public static void main(String []args) throws IOException, Exception
    {
        File file = new File("videos\\aotl.mp4");
        App app = new App(file);


        // app.StopWatch();
        app.processVideoDissect();    //160 secs : 5.95 secs per frame
        // app.StopWatch("Video proccessing complete");
        
        // app.StopWatch();
        // app.processVideo(24);    //143 secs : 5.95 secs per frame
        // app.StopWatch();

        // app.StopWatch();
        // app.processVideo(12);    //78 secs : 6.5 secs per frame
        // app.StopWatch();
        // app.StopWatch();
        // app.processVideo(1);    //12 secs : 12 secs per frame
        // app.StopWatch();
        // app.StopWatch();
        // app.processVideo(2);    //15 secs    7.5 secs
        // app.StopWatch();
        // app.StopWatch();
        // app.processVideo(3);    // 22 secs   7.333
        // app.StopWatch();    
        
        
    }
}
